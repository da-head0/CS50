# 배열

## 이전내용 요약
```C
# include <stdio.h>

int main(void)
{
    printf("hello, Bo\n");
}
```
- main 함수: 프로그램의 시작점으로 실행버튼을 클릭하는 것과 같다
- printf: 출력을 담당
- stdio.h: printf 함수를 사용하기 위해 필요한 라이브러리
- <clang 파일명> 으로 컴파일


## 1. 컴파일링
make 프로그램을 이용하면 모든 컴파일 과저을 자동으로 처리할 수 있다.
make나 clang을 사용해서 프로그램을 실행할 때 아래 4개의 단계를 거친다.
1. Precompile (전처리)

   전처리기에 의해 수행되며, # 으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줍니다.
   ```C
   #include <stdio.h>
   ```

2. Compile (컴파일링)
   **C언어 → 어셈블리언어로 바꾸는 과정이 컴파일**
   컴파일러라고 불리는 프로그램은 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일합니다.

3. Assemble (어셈블링)
   
   **어셈블리코드 → 오브젝트코드**
   소스 코드가 어셈블리 코드로 변환되면, 다음 단계인 어셈블 단계로 어셈블리 코드를 오브젝트 코드로 변환시키는 것입니다. 
   컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업이죠. 이 변환작업은 어셈블러라는 프로그램이 수행합니다. 
   
   소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이 납니다. 그러나 그렇지 않은 경우에는 링크라 불리는 단계가 추가됩니다.

4. Link (링킹)
   
   **여러개의 오브젝트코드를 하나로 합치기**
   만약 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크라는 컴파일의 마지막 단계가 필요합니다. 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐줍니다. 예를 들어, 컴파일을 하는 동안에 CS50 라이브러리를 링크하면 오브젝트 코드는 GetInt()나 GetString() 같은 함수를 어떻게 실행할 지 알 수 있게 됩니다.

## 2. 디버깅
### (1) 버그
- 코드 속에 있는 오류
- 프로그램 실행에 실패하거나 원하는 결과를 얻지 못하게 된다.

### (2) 디버깅
- 코드에 있는 버그를 식별하고 고치는 과정
- '디버거'라는 프로그램을 사용하여 디버깅한다.

### (3) 디버거
- 디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움을 준다.
- 프로그램이 멈추는 특정 지점을 **중지점**이라고 합니다.
- 프로그래머가 프로그램을 한번에 한 행씩 실행할 수 있게 한다. (단계별로 업무 수행 가능)


## 3. 코드의 디자인
클린코드를 작성하는 것이 중요하다.
또한 많은 사람과 협업시에는 코드 작성 시 사전에 정해놓은 규칙대로 작성하여 가독성이 좋고 간결한 코드로 구현해야 한다. (회사마다 코드 작성 스타일은 다를 수 있겠지만, 가독성이 높고 간결한 코드가 좋은 코드)

## 4. 배열
### (1) 자료형마다 차지하는 메모리
컴퓨터 안에는 RAM이라는 물리적 칩이 메모리 역할을 한다. 램의 용량이 클수록 큰 프로그램을 작성할 수 있다(다다익RAM).
- bool: 불리언, 1바이트
- char: 문자, 1바이트
- int: 정수, 4바이트
- float: 실수, 4바이트
- long: (더 큰) 정수, 8바이트
- double: (더 큰) 실수, 8바이트
- string: 문자열, ?바이트

### (2) 배열이란?
여러 데이터를 메모리상에 연이어서 저장하고 이를 하나의 변수로 관리하기 위해 사용된다.

### (3) 전역변수
아래 코드에서 scores 배열의 크기를 정해주는 N이라는 변수를 새로 선언하였습니다.  
```C
#include <cs50.h>
#include <stdio.h>

const int N = 3; // 전역변수로 선언 (대문자로 선언)

int main(void)
{
    // 점수 배열 선언 및 값 저장
    int scores[N];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // 평균 점수 출력
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
}
```
scores의 크기로 전역변수를 선언했기 때문에 점수 개수가 바뀔 때 수정해야 하는 코드가 줄어듭니다. 하지만 여전히 일일히 배열의 인덱스마다 점수를 지정해줘야 합니다.

### (4) 배열의 동적 선언 및 저장
따라서 내가 직접 점수의 갯수를 입력할 수 있습니다.
```C
#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1); //scores에 저장
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[]) // return을 float로 하겠다
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}//배열의 길이만큼 루프를 돌면서 값의 합을 구하고 최종적으로 평균값을 반환합니다.
```

## 5. 문자열과 배열
- 문자열(string) 자료형의 데이터는 문자(char) 자료형의 데이터들의 배열이다. 즉, 문자열 자료형의 크기는 정해져있지 않으며, 문자 갯수에 달려있다.

- 문자열의 길이 및 탐색
(1) 문자열 내의 문자를 한 글자씩 출력하기 위해서 문자열의 마지막의 끝이 '\0'과 일치하면 끝내면 됩니다. 즉, s라는 문자열이 있다고 할 때 for (int i = 0; s[i] != ‘\0’; i++) { ..} 과 같은 루프를 사용하면 되겠죠.

(2) '\0'대신에 strlen() 함수를 사용할 수도 있습니다.
문자열의 길이를 알려주는 함수로, string.h 라이브러리 안에 포함되어 있습니다.
```C
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c\n", s[i]);
    }
}
```

## 7. 명령행 인자
main도 그 형태를 보면 하나의 함수임을 알 수 있는데요, 이젠 더이상 main() 안에 기계적으로 void 라고 입력하는 대신 아래 코드와 같이 argc, argv 를 정의해보겠습니다.
```C
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[]) //하나는 int, 하나는 배열을 입력으로 받는다
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
```

argv[0]는 기본적으로 프로그램의 이름으로 저장됩니다.
만약 하나의 입력이 더 주어진다면 argv[1]에 저장될 것입니다.
예를 들어 위 프로그램을 “arg.c”라는 이름으로 저장하고 컴파일 한 후 “./argc”로 실행해보면 “hello, world”라는 값이 출력됩니다.
명령행 인자에 주어진 값이 프로그램 이름 하나밖에 없기 때문입니다.
하지만 “./argc David”로 실행해보면 “hello, David”라는 값이 출력됩니다.
명령행 인자에 David라는 값이 추가로 입력되었고, 따라서 argc 는 2, argv[1] 은 “David”가 되기 때문입니다.
